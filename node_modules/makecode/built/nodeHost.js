"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodeHost = void 0;
const glob_1 = require("glob");
const fs = require("fs");
const util = require("util");
const http = require("http");
const https = require("https");
const url = require("url");
const zlib = require("zlib");
const crypto = require("crypto");
const languageService_1 = require("./languageService");
const deploy_1 = require("./deploy");
function createNodeHost() {
    return {
        readFileAsync: util.promisify(fs.readFile),
        writeFileAsync: util.promisify(fs.writeFile),
        mkdirAsync: util.promisify(fs.mkdir),
        rmdirAsync: util.promisify(fs.rmdir),
        existsAsync: util.promisify(fs.exists),
        unlinkAsync: util.promisify(fs.unlink),
        symlinkAsync: util.promisify(fs.symlink),
        listFilesAsync: async (directory, filename) => glob_1.glob.sync(directory + "/**/" + filename),
        requestAsync: nodeHttpRequestAsync,
        createLanguageServiceAsync: async (editor) => new languageService_1.NodeLanguageService(editor),
        getDeployDrivesAsync: deploy_1.getDeployDrivesAsync,
        getEnvironmentVariable: key => process.env[key],
        exitWithStatus: code => process.exit(code),
        cwdAsync: async () => process.cwd(),
        bufferToString: buffer => new util.TextDecoder("utf8").decode(buffer),
        stringToBuffer: (str, encoding) => Buffer.from(str, encoding),
        base64EncodeBufferAsync: async (buffer) => Buffer.isBuffer(buffer) ? buffer.toString("base64") : Buffer.from(buffer).toString("base64"),
        guidGen: () => crypto.randomUUID()
    };
}
exports.createNodeHost = createNodeHost;
function clone(v) {
    if (!v)
        return v;
    return JSON.parse(JSON.stringify(v));
}
function nodeHttpRequestAsync(options, validate) {
    let isHttps = false;
    let u = url.parse(options.url);
    if (u.protocol == "https:")
        isHttps = true;
    /* tslint:disable:no-http-string */ else if (u.protocol == "http:")
        isHttps = false;
    /* tslint:enable:no-http-string */ else
        return Promise.reject("bad protocol: " + u.protocol);
    u.headers = clone(options.headers) || {};
    let data = options.data;
    u.method = options.method || (data == null ? "GET" : "POST");
    if (validate)
        validate(u.protocol, u.method);
    let buf = null;
    u.headers["accept-encoding"] = "gzip";
    u.headers["user-agent"] = "MakeCode-CLI";
    let gzipContent = false;
    if (data != null) {
        if (Buffer.isBuffer(data)) {
            buf = data;
        }
        else if (typeof data == "object") {
            buf = Buffer.from(JSON.stringify(data), "utf8");
            u.headers["content-type"] = "application/json; charset=utf8";
            if (options.allowGzipPost)
                gzipContent = true;
        }
        else if (typeof data == "string") {
            buf = Buffer.from(data, "utf8");
            if (options.allowGzipPost)
                gzipContent = true;
        }
        else {
            throw new Error("bad data");
        }
    }
    if (gzipContent) {
        buf = zlib.gzipSync(buf);
        u.headers["content-encoding"] = "gzip";
    }
    if (buf)
        u.headers["content-length"] = buf.length;
    return new Promise((resolve, reject) => {
        const handleResponse = (res) => {
            let g = res;
            if (/gzip/.test(res.headers["content-encoding"])) {
                let tmp = zlib.createUnzip();
                res.pipe(tmp);
                g = tmp;
            }
            resolve(readResAsync(g).then(buf => {
                let text = null;
                try {
                    text = buf.toString("utf8");
                }
                catch (e) { }
                let resp = {
                    statusCode: res.statusCode,
                    headers: res.headers,
                    buffer: buf,
                    text: text,
                };
                return resp;
            }));
        };
        const req = isHttps
            ? https.request(u, handleResponse)
            : http.request(u, handleResponse);
        req.on("error", (err) => reject(err));
        req.end(buf);
    });
}
function readResAsync(g) {
    return new Promise((resolve, reject) => {
        let bufs = [];
        g.on("data", (c) => {
            if (typeof c === "string")
                bufs.push(Buffer.from(c, "utf8"));
            else
                bufs.push(c);
        });
        g.on("error", (err) => reject(err));
        g.on("end", () => resolve(Buffer.concat(bufs)));
    });
}
//# sourceMappingURL=nodeHost.js.map