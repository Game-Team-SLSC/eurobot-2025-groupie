"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeLanguageService = void 0;
const vm = require("vm");
const util = require("util");
const mkc = require("makecode-core/built/mkc");
class NodeLanguageService {
    constructor(editor) {
        this.editor = editor;
        this.sandbox = {
            eval: (str) => vm.runInContext(str, this.sandbox, {
                filename: "eval",
            }),
            Function: undefined,
            setTimeout: setTimeout,
            clearInterval: clearInterval,
            clearTimeout: clearTimeout,
            setInterval: setInterval,
            clearImmediate: clearImmediate,
            setImmediate: setImmediate,
            TextEncoder: util.TextEncoder,
            TextDecoder: util.TextDecoder,
            Buffer: Buffer,
            pxtTargetBundle: {},
            scriptText: {},
            global: null,
            console: {
                log: (s) => mkc.log(s),
                debug: (s) => mkc.debug(s),
                warn: (s) => mkc.error(s),
            },
        };
        this.sandbox.global = this.sandbox;
        vm.createContext(this.sandbox, {
            codeGeneration: {
                strings: false,
                wasm: false,
            },
        });
        const ed = this.editor;
        ed.targetJson.compile.keepCppFiles = true;
        this.sandbox.pxtTargetBundle = ed.targetJson;
        this.runScript(ed.pxtWorkerJs, ed.website + "/pxtworker.js");
    }
    async registerDriverCallbacksAsync(callbacks) {
        this.runFunctionSync("pxt.setupSimpleCompile", [callbacks]);
        // disable packages config for now;
        // otherwise we do a HTTP request on every compile
        this.runSync("pxt.packagesConfigAsync = () => Promise.resolve({})");
    }
    async setWebConfigAsync(config) {
        this.runFunctionSync("pxt.setupWebConfig", [
            config
        ]);
    }
    async getWebConfigAsync() {
        return this.runSync("pxt.webConfig");
    }
    async getAppTargetAsync() {
        return this.runSync("pxt.appTarget");
    }
    async getTargetConfigAsync() {
        return this.editor.targetConfig;
    }
    async supportsGhPackagesAsync() {
        return !!this.runSync("pxt.simpleInstallPackagesAsync");
    }
    async setHwVariantAsync(variant) {
        this.runFunctionSync("pxt.setHwVariant", [
            variant || "",
        ]);
    }
    async getHardwareVariantsAsync() {
        return this.runSync("pxt.getHwVariants()");
    }
    async getBundledPackageConfigsAsync() {
        return this.runSync("Object.values(pxt.appTarget.bundledpkgs).map(pkg => JSON.parse(pkg['pxt.json']))");
    }
    async getCompileOptionsAsync(prj, simpleOpts) {
        this.sandbox._opts = simpleOpts;
        return this.runAsync("pxt.simpleGetCompileOptionsAsync(_scriptText, _opts)");
    }
    async installGhPackagesAsync(projectFiles) {
        await this.runFunctionAsync("pxt.simpleInstallPackagesAsync", [
            projectFiles,
        ]);
        return projectFiles;
    }
    performOperationAsync(op, data) {
        return this.runFunctionSync("pxtc.service.performOperation", [op, data]);
    }
    async setProjectTextAsync(projectFiles) {
        this.sandbox._scriptText = projectFiles;
    }
    async enableExperimentalHardwareAsync() {
        this.runSync("(() => { pxt.savedAppTheme().experimentalHw = true; pxt.reloadAppTargetVariant() })()");
    }
    async enableDebugAsync() {
        this.runSync("(() => { pxt.options.debug = 1 })()");
    }
    async setCompileSwitchesAsync(flags) {
        this.runSync(`(() => {
            pxt.setCompileSwitches(${JSON.stringify(flags)});
            if (pxt.appTarget.compile.switches.asmdebug)
                ts.pxtc.assembler.debug = 1
        })()`);
    }
    async buildSimJsInfoAsync(result) {
        return this.runFunctionSync("pxtc.buildSimJsInfo", [result]);
    }
    runScript(content, filename) {
        const scr = new vm.Script(content, {
            filename: filename,
        });
        scr.runInContext(this.sandbox);
    }
    runWithCb(code, cb) {
        this.sandbox._gcb = cb;
        const src = "(() => { const _cb = _gcb; _gcb = null; " + code + " })()";
        const scr = new vm.Script(src);
        scr.runInContext(this.sandbox);
    }
    runAsync(code) {
        const src = `Promise.resolve().then(() => ${code})` +
            `.then(v => _cb(null, v), err => _cb(err.stack || "" + err, null))`;
        return new Promise((resolve, reject) => this.runWithCb(src, (err, res) => err ? reject(new Error(err)) : resolve(res)));
    }
    runSync(code) {
        const src = `try { _cb(null, ${code}) } ` +
            `catch (err) { _cb(err.stack || "" + err, null) }`;
        let errRes = null;
        let normRes = null;
        this.runWithCb(src, (err, res) => err ? (errRes = err) : (normRes = res));
        if (errRes)
            throw new Error(errRes);
        return normRes;
    }
    runFunctionSync(name, args) {
        return this.runSync(this.runFunctionCore(name, args));
    }
    runFunctionAsync(name, args) {
        return this.runAsync(this.runFunctionCore(name, args));
    }
    runFunctionCore(name, args) {
        let argString = "";
        for (let i = 0; i < args.length; ++i) {
            const arg = "_arg" + i;
            this.sandbox[arg] = args[i];
            if (argString)
                argString += ", ";
            argString += arg;
        }
        return `${name}(${argString})`;
    }
}
exports.NodeLanguageService = NodeLanguageService;
//# sourceMappingURL=languageService.js.map