"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bumpAsync = exports.runGitAsync = exports.needsGitCleanAsync = exports.queryAsync = exports.spawnWithPipeAsync = exports.spawnAsync = void 0;
const child_process = require("child_process");
const fs = require("fs");
const mkc = require("makecode-core/built/mkc");
const downloader_1 = require("makecode-core/built/downloader");
const semver_1 = require("semver");
const files_1 = require("makecode-core/built/files");
function spawnAsync(opts) {
    opts.pipe = false;
    return spawnWithPipeAsync(opts).then(() => { });
}
exports.spawnAsync = spawnAsync;
function spawnWithPipeAsync(opts) {
    if (opts.pipe === undefined)
        opts.pipe = true;
    let info = opts.cmd + " " + opts.args.join(" ");
    if (opts.cwd && opts.cwd != ".")
        info = "cd " + opts.cwd + "; " + info;
    mkc.log("[run] " + info);
    return new Promise((resolve, reject) => {
        let ch = child_process.spawn(opts.cmd, opts.args, {
            cwd: opts.cwd,
            env: process.env,
            stdio: opts.pipe
                ? [
                    opts.input == null ? process.stdin : "pipe",
                    "pipe",
                    process.stderr,
                ]
                : "inherit",
            shell: opts.shell || false,
        });
        let bufs = [];
        if (opts.pipe)
            ch.stdout.on("data", (buf) => {
                bufs.push(buf);
                if (!opts.silent) {
                    process.stdout.write(buf);
                }
            });
        ch.on("close", (code) => {
            if (code != 0 && !opts.allowNonZeroExit)
                reject(new Error("Exit code: " + code + " from " + info));
            resolve(Buffer.concat(bufs));
        });
        if (opts.input != null)
            ch.stdin.end(opts.input, "utf8");
    });
}
exports.spawnWithPipeAsync = spawnWithPipeAsync;
let readlineCount = 0;
function readlineAsync() {
    process.stdin.resume();
    process.stdin.setEncoding("utf8");
    readlineCount++;
    return new Promise((resolve, reject) => {
        process.stdin.once("data", (text) => {
            process.stdin.pause();
            resolve(text);
        });
    });
}
function queryAsync(msg, defl) {
    process.stdout.write(`${msg} [${defl}]: `);
    return readlineAsync().then(text => {
        text = text.trim();
        if (!text)
            return defl;
        else
            return text;
    });
}
exports.queryAsync = queryAsync;
function needsGitCleanAsync() {
    return Promise.resolve()
        .then(() => spawnWithPipeAsync({
        cmd: "git",
        args: ["status", "--porcelain", "--untracked-files=no"],
    }))
        .then(buf => {
        if (buf.length)
            throw new Error("Please commit all files to git before running 'makecode --bump'");
    });
}
exports.needsGitCleanAsync = needsGitCleanAsync;
function runGitAsync(...args) {
    return spawnAsync({
        cmd: "git",
        args: args,
        cwd: ".",
    });
}
exports.runGitAsync = runGitAsync;
async function bumpAsync(prj, versionFile, stage, release) {
    var _a, _b, _c, _d;
    if (stage)
        mkc.log(`operation staged, skipping git commit/push`);
    if (!stage) {
        await needsGitCleanAsync();
        await runGitAsync("pull");
    }
    const configs = await (0, files_1.monoRepoConfigsAsync)(prj.directory, true);
    const currentVersion = await (0, files_1.collectCurrentVersionAsync)(configs);
    let newV;
    if (release)
        newV = (0, semver_1.inc)(currentVersion, release);
    else
        newV = await queryAsync("New version", (0, semver_1.inc)(currentVersion, "patch"));
    const newTag = "v" + newV;
    mkc.log(`new version: ${newV}`);
    if (versionFile) {
        const cfg = prj.mainPkg.config;
        mkc.debug(`writing version in ${versionFile}`);
        const versionSrc = `
// Auto-generated file: do not edit.
namespace ${cfg.name
            .replace(/^pxt-/, "")
            .split(/-/g)
            .map((p, i) => (i == 0 ? p : p[0].toUpperCase() + p.slice(1)))
            .join("")} {
    /**
     * Version of the package
     */
    export const VERSION = "${newTag}"
}`;
        fs.writeFileSync(versionFile, versionSrc, { encoding: "utf-8" });
    }
    for (const fn of configs) {
        const cfg0 = JSON.parse(fs.readFileSync(fn, "utf8"));
        if (((_b = (_a = cfg0 === null || cfg0 === void 0 ? void 0 : cfg0.codal) === null || _a === void 0 ? void 0 : _a.libraries) === null || _b === void 0 ? void 0 : _b.length) == 1) {
            const lib = cfg0.codal.libraries[0];
            if (lib.endsWith("#v" + cfg0.version)) {
                mkc.debug(`updating codal library in ${fn}`);
                cfg0.codal.libraries[0] = lib.replace(/#.*/, "#v" + newV);
            }
        }
        cfg0.version = newV;
        mkc.debug(`updating ${fn}`);
        fs.writeFileSync(fn, mkc.stringifyConfig(cfg0));
    }
    if (!stage) {
        await runGitAsync("commit", "-a", "-m", newV);
        await runGitAsync("tag", newTag);
        await runGitAsync("push");
        await runGitAsync("push", "--tags");
        const urlinfo = await spawnWithPipeAsync({
            cmd: "git",
            args: ["remote", "get-url", "origin"],
            pipe: true,
        }).then(v => v, err => {
            mkc.error(err);
            return null;
        });
        const url = (_c = urlinfo === null || urlinfo === void 0 ? void 0 : urlinfo.toString("utf8")) === null || _c === void 0 ? void 0 : _c.trim();
        if (url) {
            const slug = url.replace(/.*github\.com\//i, "");
            if (slug != url) {
                mkc.log(`Github slug ${slug}; refreshing makecode.com cache`);
                const res = await (0, downloader_1.httpGetJsonAsync)("https://makecode.com/api/gh/" + slug + "/refs?nocache=1");
                const sha = (_d = res === null || res === void 0 ? void 0 : res.refs) === null || _d === void 0 ? void 0 : _d["refs/tags/" + newTag];
                mkc.debug(`refreshed ${newV} -> ${sha}`);
            }
        }
    }
}
exports.bumpAsync = bumpAsync;
//# sourceMappingURL=bump.js.map