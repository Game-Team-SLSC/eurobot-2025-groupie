import mkc = require("./mkc");
import { LanguageService } from "./host";
export interface HexInfo {
    hex: string[];
}
export interface ExtensionInfo {
    sha: string;
    compileData: string;
    skipCloudBuild?: boolean;
    hexinfo?: HexInfo;
    appVariant?: string;
}
export interface ExtensionTarget {
    extinfo: ExtensionInfo;
}
export interface CompileOptions {
    fileSystem: pxt.Map<string>;
    testMode?: boolean;
    sourceFiles?: string[];
    generatedFiles?: string[];
    jres?: pxt.Map<pxt.JRes>;
    noEmit?: boolean;
    forceEmit?: boolean;
    ast?: boolean;
    breakpoints?: boolean;
    trace?: boolean;
    justMyCode?: boolean;
    computeUsedSymbols?: boolean;
    computeUsedParts?: boolean;
    name?: string;
    warnDiv?: boolean;
    bannedCategories?: string[];
    skipPxtModulesTSC?: boolean;
    skipPxtModulesEmit?: boolean;
    embedMeta?: string;
    embedBlob?: string;
    extinfo?: ExtensionInfo;
    otherMultiVariants?: ExtensionTarget[];
}
export interface BuiltSimJsInfo {
    js: string;
    targetVersion: string;
    fnArgs?: pxt.Map<String[]>;
    parts?: string[];
    usedBuiltinParts?: string[];
    allParts?: string[];
    breakpoints?: number[];
}
export declare enum DiagnosticCategory {
    Warning = 0,
    Error = 1,
    Message = 2
}
export interface LocationInfo {
    fileName: string;
    start: number;
    length: number;
    line: number;
    column: number;
    endLine?: number;
    endColumn?: number;
}
export interface DiagnosticMessageChain {
    messageText: string;
    category: DiagnosticCategory;
    code: number;
    next?: DiagnosticMessageChain;
}
export interface KsDiagnostic extends LocationInfo {
    code: number;
    category: DiagnosticCategory;
    messageText: string | DiagnosticMessageChain;
}
export interface CompileResult {
    outfiles: pxt.Map<string>;
    diagnostics: KsDiagnostic[];
    success: boolean;
    times: pxt.Map<number>;
    usedArguments?: pxt.Map<string[]>;
    usedParts?: string[];
    binaryPath?: string;
    simJsInfo?: BuiltSimJsInfo;
}
export interface ServiceUser {
    linkedPackage: (id: string) => Promise<pxt.Map<string>>;
}
export declare class Ctx {
    editor: mkc.DownloadedEditor;
    lastUser: ServiceUser;
    private makerHw;
    supportsGhPkgs: boolean;
    languageService: LanguageService;
    constructor(editor: mkc.DownloadedEditor);
    initAsync(): Promise<void>;
    setUserAsync(user: ServiceUser): Promise<void>;
    private compileExtInfo;
    simpleCompileAsync(prj: mkc.Package, simpleOpts?: any): Promise<CompileResult>;
    buildSimJsInfoAsync(result: CompileResult): Promise<BuiltSimJsInfo>;
    private setHwVariantAsync;
    getOptionsAsync(prj: mkc.Package, simpleOpts?: any): Promise<mkc.service.CompileOptions>;
    installGhPackagesAsync(prj: mkc.Package): Promise<void>;
    getHardwareVariantsAsync(): Promise<pxt.PackageConfig[]>;
    dispose(): void;
}
