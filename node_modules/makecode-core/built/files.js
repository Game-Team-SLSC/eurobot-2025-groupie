"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectCurrentVersionAsync = exports.monoRepoConfigsAsync = exports.savePxtModulesAsync = exports.saveBuiltFilesAsync = exports.writeFilesAsync = exports.mkHomeCacheAsync = exports.readProjectAsync = exports.readPrjFileAsync = exports.fileExistsAsync = exports.relativePath = exports.findProjectDirAsync = exports.findParentDirWithAsync = void 0;
const path = require("path");
const mkc = require("./mkc");
const host_1 = require("./host");
const semver_1 = require("./semver");
async function findParentDirWithAsync(base, filename) {
    let s = base;
    while (true) {
        if (await (0, host_1.host)().existsAsync(path.join(s, filename)))
            return s;
        const s2 = path.resolve(path.join(s, ".."));
        if (s == s2)
            return null;
        s = s2;
    }
}
exports.findParentDirWithAsync = findParentDirWithAsync;
async function findProjectDirAsync() {
    return findParentDirWithAsync(await (0, host_1.host)().cwdAsync(), "pxt.json");
}
exports.findProjectDirAsync = findProjectDirAsync;
function resolveFilename(dir, filename) {
    const resolved = path.resolve(dir, filename);
    if (resolved.startsWith(path.resolve(".", dir)))
        return resolved;
    throw new Error(`Invalid file name: ${filename} (in ${dir})`);
}
function relativePath(currdir, target) {
    return path.relative(currdir, target);
}
exports.relativePath = relativePath;
function fileExistsAsync(name) {
    return (0, host_1.host)().existsAsync(name);
}
exports.fileExistsAsync = fileExistsAsync;
function readPrjFileAsync(dir, filename) {
    return (0, host_1.host)().readFileAsync(resolveFilename(dir, filename), "utf8");
}
exports.readPrjFileAsync = readPrjFileAsync;
async function readProjectAsync(dir) {
    const pxtJson = await (0, host_1.host)().readFileAsync(path.join(dir, "pxt.json"), "utf8");
    const res = {
        config: JSON.parse(pxtJson),
        mkcConfig: null,
        files: {
            "pxt.json": pxtJson,
        },
    };
    for (const fn of res.config.files.concat(res.config.testFiles || [])) {
        res.files[fn] = await (0, host_1.host)().readFileAsync(resolveFilename(dir, fn), "utf8");
    }
    return res.files;
}
exports.readProjectAsync = readProjectAsync;
function homePxtDir() {
    return path.join((0, host_1.host)().getEnvironmentVariable("HOME") || (0, host_1.host)().getEnvironmentVariable("UserProfile"), ".pxt");
}
async function mkHomeCacheAsync(dir) {
    if (!dir)
        dir = homePxtDir();
    await mkdirpAsync(dir);
    const rootPath = path.join(dir, "mkc-cache");
    await mkdirpAsync(rootPath);
    function expandKey(key) {
        return key.replace(/[^\.a-z0-9_\-]/g, c => "_" + c.charCodeAt(0) + "_");
    }
    function keyPath(key) {
        return path.join(rootPath, expandKey(key));
    }
    return {
        rootPath,
        expandKey,
        getAsync: key => (0, host_1.host)().readFileAsync(keyPath(key)).then(buf => buf, err => null),
        setAsync: (key, val) => (0, host_1.host)().writeFileAsync(keyPath(key), val),
    };
}
exports.mkHomeCacheAsync = mkHomeCacheAsync;
async function mkdirpAsync(dirname, lev = 5) {
    if (!await (0, host_1.host)().existsAsync(dirname)) {
        if (lev > 0)
            await mkdirpAsync(path.resolve(dirname, ".."), lev - 1);
        await (0, host_1.host)().mkdirAsync(dirname);
    }
}
async function writeFilesAsync(built, outfiles, log = false) {
    await mkdirpAsync(built);
    for (let fn of Object.keys(outfiles)) {
        if (fn.indexOf("/") >= 0)
            continue;
        if (log)
            mkc.log(`write ${built}/${fn}`);
        if (/\.(uf2|pxt64|elf)$/.test(fn))
            await (0, host_1.host)().writeFileAsync(path.join(built, fn), outfiles[fn], "base64");
        else
            await (0, host_1.host)().writeFileAsync(path.join(built, fn), outfiles[fn], "utf8");
    }
}
exports.writeFilesAsync = writeFilesAsync;
async function saveBuiltFilesAsync(dir, res, folder = "built") {
    await writeFilesAsync(path.join(dir, folder), res.outfiles || {}, true);
}
exports.saveBuiltFilesAsync = saveBuiltFilesAsync;
async function savePxtModulesAsync(dir, files) {
    for (const k of Object.keys(files))
        if (k.startsWith("pxt_modules/")) {
            await mkdirpAsync(path.dirname(k));
            const v = files[k];
            if (typeof v == "string") {
                mkc.debug(`    write ${k}`);
                await (0, host_1.host)().writeFileAsync(k, v);
            }
            else {
                mkc.debug(`    link ${k}`);
                try {
                    await (0, host_1.host)().unlinkAsync(k);
                }
                catch (_a) { }
                await (0, host_1.host)().symlinkAsync(v.symlink, k, "file");
            }
        }
}
exports.savePxtModulesAsync = savePxtModulesAsync;
async function monoRepoConfigsAsync(folder, includingSelf = true) {
    const files = await (0, host_1.host)().listFilesAsync(folder, "pxt.json");
    return files.filter(e => e.indexOf("pxt_modules") < 0 &&
        e.indexOf("node_modules") < 0 &&
        (includingSelf ||
            path.resolve(folder, "pxt.json") != path.resolve(e)));
}
exports.monoRepoConfigsAsync = monoRepoConfigsAsync;
async function collectCurrentVersionAsync(configs) {
    let version = (0, semver_1.tryParse)("0.0.0");
    for (const config of configs) {
        const cfg = JSON.parse(await (0, host_1.host)().readFileAsync(config, "utf8"));
        const v = (0, semver_1.tryParse)(cfg.version);
        if (v && (0, semver_1.cmp)(version, v) < 0)
            version = v;
    }
    return (0, semver_1.stringify)(version);
}
exports.collectCurrentVersionAsync = collectCurrentVersionAsync;
//# sourceMappingURL=files.js.map