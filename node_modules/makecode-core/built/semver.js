"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortLatestTags = exports.inRange = exports.compareStrings = exports.majorCmp = exports.stringify = exports.normalize = exports.tryParse = exports.parse = exports.cmp = void 0;
function cmp(a, b) {
    if (!a)
        if (!b)
            return 0;
        else
            return 1;
    else if (!b)
        return -1;
    else {
        let d = a.major - b.major || a.minor - b.minor || a.patch - b.patch;
        if (d)
            return d;
        if (a.pre.length == 0 && b.pre.length > 0)
            return 1;
        if (a.pre.length > 0 && b.pre.length == 0)
            return -1;
        for (let i = 0; i < a.pre.length + 1; ++i) {
            let aa = a.pre[i];
            let bb = b.pre[i];
            if (!aa)
                if (!bb)
                    return 0;
                else
                    return -1;
            else if (!bb)
                return 1;
            else if (/^\d+$/.test(aa))
                if (/^\d+$/.test(bb)) {
                    d = parseInt(aa) - parseInt(bb);
                    if (d)
                        return d;
                }
                else
                    return -1;
            else if (/^\d+$/.test(bb))
                return 1;
            else {
                d = strcmp(aa, bb);
                if (d)
                    return d;
            }
        }
        return 0;
    }
}
exports.cmp = cmp;
function parse(v, defaultVersion) {
    let r = tryParse(v) || tryParse(defaultVersion);
    return r;
}
exports.parse = parse;
function tryParse(v) {
    if (!v)
        return null;
    if ("*" === v) {
        return {
            major: Number.MAX_SAFE_INTEGER,
            minor: Number.MAX_SAFE_INTEGER,
            patch: Number.MAX_SAFE_INTEGER,
            pre: [],
            build: []
        };
    }
    if (/^v\d/i.test(v))
        v = v.slice(1);
    let m = /^(\d+)\.(\d+)\.(\d+)(-([0-9a-zA-Z\-\.]+))?(\+([0-9a-zA-Z\-\.]+))?$/.exec(v);
    if (m)
        return {
            major: parseInt(m[1]),
            minor: parseInt(m[2]),
            patch: parseInt(m[3]),
            pre: m[5] ? m[5].split(".") : [],
            build: m[7] ? m[7].split(".") : []
        };
    return null;
}
exports.tryParse = tryParse;
function normalize(v) {
    return stringify(parse(v));
}
exports.normalize = normalize;
function stringify(v) {
    let r = v.major + "." + v.minor + "." + v.patch;
    if (v.pre.length)
        r += "-" + v.pre.join(".");
    if (v.build.length)
        r += "+" + v.build.join(".");
    return r;
}
exports.stringify = stringify;
function majorCmp(a, b) {
    let aa = tryParse(a);
    let bb = tryParse(b);
    return aa.major - bb.major;
}
exports.majorCmp = majorCmp;
/**
 * Compares two semver version strings and returns -1 if a < b, 1 if a > b and 0
 * if versions are equivalent. If a and b are invalid versions, classic strcmp is called.
 * If a (or b) is an invalid version, it is considered greater than any version (strmp(undefined, "0.0.0") = 1)
 */
function compareStrings(a, b) {
    let aa = tryParse(a);
    let bb = tryParse(b);
    if (!aa && !bb)
        return strcmp(a, b);
    else
        return cmp(aa, bb);
}
exports.compareStrings = compareStrings;
function inRange(rng, v) {
    let rngs = rng.split(' - ');
    if (rngs.length != 2)
        return false;
    let minInclusive = tryParse(rngs[0]);
    let maxExclusive = tryParse(rngs[1]);
    if (!minInclusive || !maxExclusive)
        return false;
    if (!v)
        return true;
    const lwr = cmp(minInclusive, v);
    const hr = cmp(v, maxExclusive);
    return lwr <= 0 && hr < 0;
}
exports.inRange = inRange;
/**
 * Filters and sort tags from latest to oldest (semver wize)
 * @param tags
 */
function sortLatestTags(tags) {
    const v = tags.filter(tag => !!tryParse(tag));
    v.sort(compareStrings);
    v.reverse();
    return v;
}
exports.sortLatestTags = sortLatestTags;
function strcmp(a, b) {
    if (a == b)
        return 0;
    if (a < b)
        return -1;
    else
        return 1;
}
//# sourceMappingURL=semver.js.map